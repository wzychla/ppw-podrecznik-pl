\section{Projektowanie zorientowane obiektowo}

\subsection{Dlaczego używamy języków obiektowych}

C\# jest kolejnym językiem obiektowym, jaki w ciągu ostatnich lat został udostępniony programistom.
Można więc zapytać: czy kod obiektowy tworzy się szybciej niż kod nieobiektowy albo czy 
programy obiektowe działają szybciej niż nieobiektowe? Okazuje się, że niekoniecznie. Dlaczego więc
języki obiektowe uznawane są za tak ważne? 

Odpowiedź jest wbrew pozorom dość prosta. Otóż to właśnie języki obiektowe najlepiej nadają się
do modelowania problemów z otaczającego nas świata. Możliwość zamykania jakiejś ustalonej funkcjonalności
w obiekcie dysponującym określonym interfejsem, czyli sposobem w jaki ten obiekt komunikuje się z innymi,
pozwala programiście łatwiej skupić się na modelowanym problemie.

Języki obiektowe doskonale sprawdzają się tam, gdzie programista stoi przed zadaniem napisania programu
użytkowego, który pozwalałby na rejestrowanie i analizę procesów, o zależnościach pomiędzy którymi 
coś już wiadomo. Język obiektowy doskonale sprawdzą się więc w aplikacji do zarządzania jakimiś
instytucjami, w aplikacjach finansowo-księgowych, w aplikacjach dla służb medycznych czy oświaty. 
Ale to nie wszystko - dzięki prostej składni języki obiektowe równie dobrze radzą sobie tam, gdzie 
zwykle używamy prostszych języków imperatywnych, czyli na przykład w aplikacjach obliczeniowych,
aplikacjach o złożonych strukturach danych i skomplikowanych algorytmach operujących na tych strukturach.

Na języki obiektowe należy więc patrzeć jak na naturalne rozszerzenie prostych języków
imperatywnych. Tam gdzie celem jest bardzo bliska interakcja ze sprzętem (na przykład przy programowaniu
sterowników urządzeń) lub tam gdzie wydajność jest celem nadrzędnym, tam programista powinien zdecydować się
na język maszynowy lub prosty język imperatywny o wydajności zbliżonej do języka maszynowego, na przyład C.
Tam gdzie celem jest dokładność zamodelowania jakiegoś problemu oraz łatwość konserwacji kodu i podatność
na modyfikacje, zwykle najlepszy okaże się język obiektowy. 

\subsection{Reguły modelowania obiektowego}

W inżynierii oprogramowania zazwyczaj wyróżnia się kilka faz tworzenia oprogramowania. 

\begin{enumerate}
\item Poznawanie i analiza problemu
\item Tworzenie modelu obiektowego, projektowanie interfejsu i funkcji programu
\item Implementacja
\item Testowanie
\end{enumerate}

Podczas pracy nad projektem żadna z tych faz nie może być pominięta, nie powinno się też zamieniać
kolejności poszczególnych etapów. Nie jest możliwe tworzenie modelu bez dokładnego poznania problemu. 
Nie można pisać kodu, jednocześnie tworząc model obiektowy. Trudno jest w końcu prowadzić miarodajne testy,
kiedy program jest w początkowej fazie rozwoju.

W praktyce jednak praca nad projektem w różnych fazach napotyka na różne trudności, najczęściej wynikające
z dostosowywania pierwotnych założeń do możliwości ich wykonania. Dlatego też poszczególne fazy przeplatają się,
bardzo często następuje powrót do wcześniej rozważanych zagadnień.

W większych zespołach programistycznych istnieje ścisły podział funkcji związany z realizacją poszczególnych
faz projektu. W mniejszych zespołach zdarza się, że jedna osoba pełni kilka funkcji. W szczególnych przypadkach
jedna osoba może być odpowiedzialna za wszystkie fazy tworzenia 
oprogramowania\footnote{Takie podejście bywa zgubne. Łatwo wskazać programy, w których mimo znakomitego
rozpoznania problemu kuleje strona programistyczna oraz takie, które są bardzo zaawansowane programistycznie,
a słabe pod względem merytorycznym.}. 
\begin{description}
\item [Konsultant] Osoba (najczęściej oddelegowana przez zleceniodawcę) znająca wszelkie szczegóły związane
z merytoryczną stroną problemu, którego ma dotyczyć aplikacja (faza 1).
\item [Analityk] Zajmuje się poznawaniem i analizą potrzeb zlecieniodawcy i tworzeniem zarysów modelu
obiektowego (fazy 1-2).
\item [Projektant] Zajmuje się tworzeniem modelu obiektowego, projektowaniem funkcji programu oraz 
kształtem interfejsu użytkownika.
\item [Programista] Bieże udział w projektowaniu modelu obiektowego, a następnie zajmuje się tworzeniem 
kodu (fazy 2-3).
\item [Tester] Zajmuje się testowaniem programu.
\end{description}

\subsection{Analiza i projektowanie}

Analiza problemu zwyke rozpoczyna się od określenia przez użytkownika jego wizji i oczekiwań związanych
z tworzonym oprogramowaniem. Analityk musi zwrócić uwagę na główne potrzeby systemu, na przypadki 
szczególne oraz na to które elementy modelu pozostaną względnie stałe, a które mogą podlegać zmianom,
związanym z różnymi czynnikami\footnote{Prawo zmienia się, niestety, dość często. Bezpośrednio
wpływa to na sposoby funkcjonowania systemów informatycznych.}.

Analityk w trakcie kontaktów z użytkownikiem powinien zwracać uwagę na dwie płaszczyzny funkcjonowania systemu
\begin{description}
\item [część statyczną] czyli zakres gromadzonych informacji i sposób ich przechowywania
\item [część dynamiczną] czyli tworzenie zależności między danymi 
\end{description}

Pierwszy model obiektowy może powstać według następującego algorytmu:
\begin{enumerate}
\item Podczas kontaktu z użytkownikiem rób jak najwięcej notatek dotyczących istotnych dla problemu zagadnień
\item Przejrzyj notatki, podkreślając w nich wszystkie {\em rzeczowniki}, bezpośrednio odnoszące się do
problemu
\item Utwórz klasę dla każdego podkreślonego rzeczownika
\item Określ wszystkie właściwości utworzonych klas i utwórz w klasach odpowiednie pola. Jeśli
jakaś właściwość dotyczy klasy jako całości, utwórz pole statyczne w klasie.
\item Przejrzyj notatki, podkreślając w nich wszystkie czasowniki związane z wyodrębnionymi
rzeczownikami. 
\item Utwórz metody w klasach dla każdego podkreślonego czasownika. Jeśli jakaś akcja dotyczy klasy
jako całości, utwórz metodę statyczną.
\end{enumerate}

Model obiektowy utworzony według powyższego algorytmu powinien być rozszerzony o informacje 
o wzajemnych relacjach między klasami. Istnieją cztery rodzaje relacji między obiektami.

\subsubsection{Relacja {\em jest rodzajem}}

Relacja {\em jest rodzajem} oznacza, że jedna klasa jest uszczegółowioną wersją innej. W praktyce oznacza to, że
między klasami zachodzi relacja dziedziczenia.

\begin{scriptsize}
\begin{verbatim}
public class Student
{
}

public class StudentInformatyki : Student
{
}
\end{verbatim}
\end{scriptsize}

\subsubsection{Relacja {\em zawiera}}

Jeśli obiekt jednego typu może zawierać obiekt innego typu, to zależność taką uwzględnia się
przez dodanie w klasie odpowiedniego pola.

\begin{scriptsize}
\begin{verbatim}
public class ArkuszOcen
{
}

public class Student
{
  ArkuszOcen arkuszOcen
}
\end{verbatim}
\end{scriptsize}

Jeżeli jedna z klas nie jest klasą samodzielną, to znaczy nie ma potrzeby tworzenia
obiektów tej klasy przez inne klasy, to można utworzyć klasę wewnętrzną, niedostępną z zewnątrz.

\begin{scriptsize}
\begin{verbatim}
public class Student
{
  public class ArkuszOcen
  {
  }

  ArkuszOcen arkuszOcen
}
\end{verbatim}
\end{scriptsize}

\subsubsection{Relacja {\em używa}}

Jeśli obiekty jednego typu podczas wykonywania jakichś akcji korzystają z innych obiektów, to 
taką relację implementuje się tworząc metody o odpowiednich parametrach.

\begin{scriptsize}
\begin{verbatim}
public class Ocena
{
}

public class Student
{
  void uzyskalOcene( Ocena ocena );
}
\end{verbatim}
\end{scriptsize}

\subsubsection{Relacja {\em tworzy}}

Jeśli w wyniku jakichś działań inicjowanych przez obiekt danej klasy powstaje obiekt innej klasy, mamy do
czynienia z relacją {\em tworzy}. Relację taką implementuje się tworząc odpowiednie metody.

\begin{scriptsize}
\begin{verbatim}
public class PracaMagisterska
{
}

public class Student
{
  PracaMagisterska piszePraceMagisterska()
  {
    PracaMagisterska m = new PracaMagisterska();
    ...
    return m;
  }
}
\end{verbatim}
\end{scriptsize}

\subsection{Narzędzia wspierające modelowanie obiektowe}

