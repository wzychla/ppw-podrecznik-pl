\chapter*{Zamiast wstępu}

\section*{Plan wykładu}

\begin{enumerate}

\item Wprowadzenie (20 luty)
	\begin{itemize}
	\item Historia systemu Windows
	\item Rozwój metod programowania
	\item Przegląd języków i narzędzi programistycznych
	\end{itemize}
\item Podstawy programowania systemu Windows (27 luty)
	\begin{itemize}
	\item Tworzenie okien 
	\item Okna macierzyste i okna potomne
	\item Komunikaty 
	\end{itemize}
\item Przegląd bibliotek Win32API (6 marzec)
	\begin{itemize}
	\item Subclassowanie okien potomnych
	\item GDI
	\item Zegary
	\item Menu
	\item Powłoka systemu
	\end{itemize}
\item Zaawansowane metody programowania Win32API (13 marzec)
	\begin{itemize}
	\item Biblioteki ładowane dynamicznie (DLL)
	\item Procesy, wątki
	\item Synchronizacja wątków
	\item Podstawy biblioteki Winsock
	\end{itemize}

\item Podstawowe elementy języka C\# (20 marzec)
	\begin{itemize}
	\item Schemat działania platformy .NET
	\item Common type system
	\item Model obiektowy, klasy 
	\end{itemize}
\item Podstawowe elementy języka C\# (27 marzec)
	\begin{itemize}
	\item Struktury, iterfejsy
	\item Przeciążanie operatora
	\item Dokumentowanie kodu	
	\end{itemize}
\item Podstawowe elementy języka C\# (3 kwiecień)
	\begin{itemize}
	\item Konwersje między typami
	\item Wyjątki
	\item Delegaci, zdarzenia
	\item Moduły 
	\item Refleksje
	\item Unsafe code
	\item Dekompilacja
	\end{itemize}

\item Przegląd bibliotek platformy .NET (10 kwiecień)
	\begin{itemize}
	\item Modelowanie obiektowe
	\item Kolekcje wbudowane
	\item Wejście / wyjście
	\end{itemize}
\item Przegląd bibliotek platformy .NET (17 kwiecień)
	\begin{itemize}
	\item Wątki, procesy
	\item Serializacja
	\item Wyrażenia regularne
	\item Wołanie kodu natywnego
	\item Kompilacja w czasie wykonania programu 
	\item XML
	\item WMI
	\item DirectX.NET
	\end{itemize}
	
\item Aplikacje okienkowe (24 kwiecień)
	\begin{itemize}
	\item Tworzenie okien 
	\item Okna macierzyste i okna potomne
	\item Zdarzenia
	\end{itemize}
\item Aplikacje okienkowe (8 maj)
	\begin{itemize}
	\item Subclassowanie okien potomnych
	\item Przegląd komponentów
	\item GDI+
	\end{itemize}
\item Aplikacje okienkowe (15 maj)
	\begin{itemize}
	\item Zegary
	\item Menu
	\item Schowek
	\item Drag \& drop
	\item Tworzenie własnych komponentów
	\end{itemize}

\item ADO.NET, ASP.NET (22 maj)

\item Inne języki platformy .NET (29 maj)
	\begin{itemize}
	\item ILAsm
	\item VB.NET
	\item SML.NET
	\item Łączenie kodu różnych języków
	\end{itemize}

\item Bezpieczeństwo (5 czerwiec)
	\begin{itemize}
	\item Bezpieczny język pośredni
	\item Bezpieczne aplikacje
	\end{itemize}

\end{enumerate}

\section*{Dla kogo jest ten skrypt}

Skrypt skierowany jest do programistów, którzy chcą dowiedzieć się jakich narzędzi i języków używać
aby pisać programy pod Windows oraz jak wygląda sam system widziany oczami programisty. Powstał jako
materiał pomocniczny do wykładu "Programowanie pod Windows", układ materiału odpowiada więc 
przebiegowi wykładu.

Zakładam, że czytelnik potrafi programować w C, wie co to jest kompilator, kod źródłowy i wynikowy, zna
trochę C++ lub Javę. Dość dokładnie omawiam elementy języka C\#, można więc rozdział poświęcony omówieniu
tego języka potraktować jako mini-leksykon C\#.

Poznawanie nowych języków i metod programwania traktuję jako nie tylko pracę ale i bardzo uzależniające
hobby. Ucząc się nowych rzeczy, czytam to co autor ma do powiedzenia na ich temat, a potem
staram się dokładnie analizować listingi przykładowych programów. Niestety, bardzo często zdarza się, że
kody przykładowych programów w książkach są koszmarnie długie! Autorzy przykładów być może kierują się
przekonaniem, że przykładowy kod powinien wyczerpywać demonstrowane zagadnienie w sposób pełny, a
ponadto zapoznać czytelnika przy okazji z paroma dodatkowymi, czasami niezwiązanymi z tematem, elementami. Tylko
jak, chcąc nauczyć się czegoś szybko, znaleźć czas na analizę czasami kilkunastu stron kodu źródłowego,
aby między 430 a 435 wierszem znaleźć interesujący mnie fragment?

Nie potrafię odpowiedzieć na to pytanie. Dlatego kody przykładowych programów w tym skrypcie są bardzo
krótkie, czasami wręcz symboliczne. Zakładam bowiem, że programista który chce na przykład dowiedzieć się
jak działa {\em ArrayList} nie potrzebuje jako przykładu 10 stron kodu źródłowego prostej aplikacji bazodanowej,
tylko 10-15 linijek demonstrujących użycie tego a nie innego obiektu. Mimo to przeważająca większość 
przykładów to kompletne programy, gotowe do uruchomienia.

Zapraszam do lektury.
